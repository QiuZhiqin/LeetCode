//判断二叉树是否对称
class Solution
{
public:
    bool check(TreeNode *p, TreeNode *q)
    {
        if (!p && !q)
            return true;
        if (!p || !q)
            return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);//p的左孩子与q的右孩子应该相等
    }
    bool isSymmetric(TreeNode *root)
    {
        return check(root, root);
    }
};

//层序遍历
vector<vector<int>> levelOrder(TreeNode *root)
{
    vector<vector<int>> ans;
    queue<TreeNode *> temp;
    if (!root)
        return ans;
    temp.push(root);
    while (!temp.empty())
    {
        int levelsize = temp.size();
        ans.push_back(vector<int>{});
        for (int i = 0; i < levelsize; i++)
        {
            auto node = temp.front();
            temp.pop();
            ans.back().push_back(node->val);
            if (node->left)
                temp.push(node->left);
            if (node->right)
                temp.push(node->right);
        }
    }
    return ans;
}

//翻转二叉树
class Solution
{
public:
    void invert(TreeNode *&root)
    {
        if (!root)
            return;
        TreeNode *temp = root->left;
        root->left = root->right;
        root->right = temp;
        invert(root->right);
        invert(root->left);
    }
    TreeNode *invertTree(TreeNode *root)
    {
        invert(root);
        return root;
    }
};
//找路径总和
class Solution
{
public:
    bool path(TreeNode *root, int targetSum, int correntSum)
    {
        if (!root)
            return false;
        correntSum = correntSum + root->val;
        if (!root->left && !root->right)//加上这句是为了确定root为叶子节点，去掉这句程序也能运行，不过路径不一定连接叶子节点
            return correntSum == targetSum;
        return path(root->left, targetSum, correntSum) || path(root->right, targetSum, correntSum);
    }
    bool hasPathSum(TreeNode *root, int targetSum)
    {
        int correntSum = 0;
        return path(root, targetSum, correntSum);
    }
};
