//岛屿最大面积
int maxAreaOfIsland(vector<vector<int>> &grid)
{
    int max_size;
    if (grid.empty() || grid[0].empty())
        return 0;
    for (int i = 0; i < grid.size(); i++)
    {
        for (int j = 0; j < grid[0].size(); j++)
            if (grid[i][j])
                max_size = max(max_size, dfs(grid, i, j));
    }
    return max_size;
}
int dfs(vector<vector<int>> &grid, int r, int c)
{
    vector<int> direction = {-1, 0, 1, 0, -1};
    if (grid[r][c] == 0)
        return 0;
    grid[r][c] = 0;
    int x, y, area = 1;
    for (int i = 0; i < 4; i++)
    {
        x = r + direction[i];
        y = c + direction[i + 1];
        if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size())
            area += dfs(grid, x, y);
    }
    return area;
}

//全排列（回溯法）
 vector<vector<int>> permute(vector<int> &nums)
{
    vector<vector<int>> ans;
    backtracking(nums, 0, ans);
    return ans;
}
void backtracking(vector<int> &nums, int level, vector<vector<int>> &ans)
{
    if (level == nums.size() - 1)
    {
        ans.push_back(nums);
        return;
    }
    for (int i = level; i < nums.size(); i++)
    {
        swap(nums[i], nums[level]);
        backtracking(nums, level + 1, ans);
        swap(nums[i], nums[level]);
    }
}

//组合（回溯法）
vector<vector<int>> combine(int n, int k)
{
    vector<vector<int>> ans;
    vector<int> comb(k, 0);
    int count = 0;
    backtracking(ans, comb, count, 1, n, k);
    return ans;
}
void backtracking(vector<vector<int>> &ans, vector<int> &comb, int &count, int pos, int n, int k)
{
    if (count == k)
    {
        ans.push_back(comb);
        return;
    }
    for (int i = pos; i <= n; ++i)
    {
        comb[count++] = i;
        backtracking(ans, comb, count, i + 1, n, k);
        --count;
    }
}
