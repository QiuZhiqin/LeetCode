//岛屿最大面积
int maxAreaOfIsland(vector<vector<int>> &grid)
{
    int max_size;
    if (grid.empty() || grid[0].empty())
        return 0;
    for (int i = 0; i < grid.size(); i++)
    {
        for (int j = 0; j < grid[0].size(); j++)
            if (grid[i][j])
                max_size = max(max_size, dfs(grid, i, j));
    }
    return max_size;
}
int dfs(vector<vector<int>> &grid, int r, int c)
{
    vector<int> direction = {-1, 0, 1, 0, -1};
    if (grid[r][c] == 0)
        return 0;
    grid[r][c] = 0;
    int x, y, area = 1;
    for (int i = 0; i < 4; i++)
    {
        x = r + direction[i];
        y = c + direction[i + 1];
        if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size())
            area += dfs(grid, x, y);
    }
    return area;
}

//全排列（回溯法）
 vector<vector<int>> permute(vector<int> &nums)
{
    vector<vector<int>> ans;
    backtracking(nums, 0, ans);
    return ans;
}
void backtracking(vector<int> &nums, int level, vector<vector<int>> &ans)
{
    if (level == nums.size() - 1)
    {
        ans.push_back(nums);
        return;
    }
    for (int i = level; i < nums.size(); i++)
    {
        swap(nums[i], nums[level]);
        backtracking(nums, level + 1, ans);
        swap(nums[i], nums[level]);
    }
}

//组合（回溯法）
vector<vector<int>> combine(int n, int k)
{
    vector<vector<int>> ans;
    vector<int> comb(k, 0);
    int count = 0;
    backtracking(ans, comb, count, 1, n, k);
    return ans;
}
void backtracking(vector<vector<int>> &ans, vector<int> &comb, int &count, int pos, int n, int k)
{
    if (count == k)
    {
        ans.push_back(comb);
        return;
    }
    for (int i = pos; i <= n; ++i)
    {
        comb[count++] = i;
        backtracking(ans, comb, count, i + 1, n, k);
        --count;
    }
}

//单词搜索（回溯法）
bool exist(vector<vector<char>> &board, string word)
{
    if (board.empty())
        return false;
    int m = board.size(), n = board[0].size();
    bool find = false;
    vector<vector<bool>> visited(m, vector<bool>(n, false));
    for (int i = 0; i < m; ++i)
    {
        for (int j = 0; j < n; ++j)
        {
            backtracking(i, j, board, word, visited, 0, find);
        }
    }
    return find;
}
void backtracking(int i, int j, vector<vector<char>> &board, string &word, vector<vector<bool>> &visited, int level, bool &find)
{
    if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size())
        return;
    if (board[i][j] != word[level] || find || visited[i][j])
        return;
    if (level == word.size() - 1)
    {
        find = true;
        return;
    }
    visited[i][j] = true;
    backtracking(i + 1, j, board, word, visited, level + 1, find);
    backtracking(i - 1, j, board, word, visited, level + 1, find);
    backtracking(i, j + 1, board, word, visited, level + 1, find);
    backtracking(i, j - 1, board, word, visited, level + 1, find);
    visited[i][j] = false;
}

//n皇后
class Solution {
public:
vector<vector<string>> solveNQueens(int n)
    {
        vector<vector<string>> ans;
        if (n == 0)
        {
            return ans;
        }
        vector<string> board(n, string(n, '.'));
        vector<bool> column(n, false), ldiag(2 * n - 1, false), rdiag(2 * n - 1, false);
        backtracking(ans, board, column, ldiag, rdiag, 0, n);
        return ans;
    }
    void backtracking(vector<vector<string>> &ans, vector<string> &board, vector<bool> &column, vector<bool> &ldiag, vector<bool> &rdiag, int row, int n)
    {
        if (row == n)
        {
            ans.push_back(board);
            return;
        }
        for (int i = 0; i < n; i++)
        {
            if (column[i] || ldiag[n - row + i - 1] || rdiag[row + i + 1])
                continue;
            board[row][i] = 'Q';
            column[i] = true;
            ldiag[n - row + i - 1] = true;
            rdiag[row + i + 1] = true;
            backtracking(ans, board, column, ldiag, rdiag, row + 1, n);
            board[row][i] = '.';
            column[i] = false;
            ldiag[n - row + i - 1] = false;
            rdiag[row + i + 1] = false;
        }
    }
};

//相同的树
bool isSameTree(TreeNode *p, TreeNode *q)
{
    if (p && q && p->val == q->val)
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    else if (!p && !q)
        return true;
    else
        return false;
}
