//爬楼梯
int climbStairs(int n)
{
    if (n <= 2)
        return n;
    int pre = 2, pree = 1, cur;
    for (int i = 2; i < n; i++)
    {
        cur = pre + pree;
        pree = pre;
        pre = cur;
    }
    return cur;
}

//抢劫
int rob(vector<int> &nums)
{
    int n = nums.size();
    if (n == 1)
        return nums[0];
    if (n == 2)
        return max(nums[0], nums[1]);
    int pre = max(nums[0], nums[1]), pree = nums[0], cur;
    for (int i = 2; i < n; i++)
    {
        cur = max(pree + nums[i], pre); //两种可能：1.第i家抢，则第i-1家不抢，则最大抢劫数目为i-1家之前（不包括i-1家）抢的
        pree = pre;                     //数目总和+第i家抢到的钱;2.不抢第i家，则最大抢劫数额为到i-1家（包括）为止抢到的钱
        pre = cur;
    }
    return cur;
}

//等差数列划分
int numberOfArithmeticSlices(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> dp(n, 0);
    for (int i = 3; i < n; i++)
    {
        if (nums[i - 1] - nums[i - 2] == nums[i] - nums[i - 1]) //判断从nums[i-2]到nums[i]的三个元素是否等差
            dp[i] = dp[i - 1] + 1;                              //若是，则相较以nums[i-1]为结尾的等差数列个数至少增加1，即(, , , ,nums[i-1])末端加上nums[i]依然等差
    }
    return accumulate(dp.begin(), dp.end(), 0); //子列可以以任意i为结尾，故需要对dp数列进行求和
}

//最小路径和
int minPathSum(vector<vector<int>> &grid)
{
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n, 0)); //建立二维dp数组来存储最小值
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i == 0 && j == 0) //位于左上角时，最小值即为当前元素值
                dp[i][j] = grid[i][j];
            else if (i == 0) //位于第一行，只可能从左边过来
                dp[i][j] = dp[i][j - 1] + grid[i][j];
            else if (j == 0) //位于第一列，只可能从上边过来
                dp[i][j] = dp[i - 1][j] + grid[i][j];
            else
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; //考虑从左、上靠近的最小值加上当前元素值
        }
    }
    return dp[m - 1][n - 1];
}

//最大正方形
int maximalSquare(vector<vector<char>> &matrix)
{
    int m = matrix.size(), n = matrix[0].size();
    int max_len = 0;
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)); //这里让dp行为m+1，列为n+1是为了方便后续判断，即第一行第一列存的元素无效
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
        {
            if (matrix[i - 1][j - 1] == '1')
                dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1; //数学推导，记住即可
            max_len = max(max_len, dp[i][j]);
        }
    return max_len * max_len;
}
