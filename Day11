//验证二叉搜索树（408真题）
class Solution {
public:
   bool f1(TreeNode *root, long low, long high)
{
    if (!root)
        return true;
    if (root->val <=low || root->val >= high)
        return false;
    return f1(root->left, low, root->val) && f1(root->right, root->val, high);
}
bool isValidBST(TreeNode *root)
{
    return f1(root, LONG_MIN, LONG_MAX);
}

//删除指定值的元素
    int removeElement(vector<int> &nums, int val)
{
    int k = 0;
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] != val)
        {
            nums[k] = nums[i];
            k++;
        }
    }
    return k;
}

//分发饼干
int findContentChildren(vector<int> &g, vector<int> &s)
{
    int child = 0;
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    for (int i = 0; i < s.size(); i++)
    {
        if (child == g.size())
            break;
        if (g[child] <= s[i])
            child++;
    }
    return child;
}

//发放糖果
 int candy(vector<int> &ratings)
{
    int size = ratings.size();
    vector<int> nums(size, 1);
    if (size <= 1)
        return size;
    for (int i = 1; i < size; i++)
    {
        if (ratings[i - 1] < ratings[i])
            nums[i] = nums[i - 1] + 1;
    }
    for (int i = size - 1; i > 0; i--)
    {
        if (ratings[i] < ratings[i - 1] && nums[i] >= nums[i - 1])
            nums[i - 1] = nums[i] + 1;
    }
    return accumulate(nums.begin(), nums.end(), 0);
}
