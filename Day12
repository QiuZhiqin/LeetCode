//无重叠区间
int eraseOverlapIntervals(vector<vector<int>> &intervals)//贪心算法，先将各区间按结尾从小到大排序，再遍历比较，如果前一个区间结尾比后一个的开头大，则移除后面一个区间
{
    if (intervals.empty())
        return 0;
    int n = intervals.size();
    sort(intervals.begin(), intervals.end(), [](vector<int> a, vector<int> b)
         { return a[1] < b[1]; });                       //按区间结尾从小到大排序
    int ans = 0, pre = intervals[0][1];
    for (int i = 1; i < n; i++)
    {
        if (intervals[i][0] < pre)
            ans++;
        else
            pre = intervals[i][1];
    }
    return ans;
}

//种花问题
bool canPlaceFlowers(vector<int> &flowerbed, int n)
{
    int max = 0, pre = 0, size = flowerbed.size();
    for (int i = 0; i < size - 1; i++)                  //判断除最后一个格外的格子是否适合种花
    {
        if (flowerbed[i] == 0 && pre == 0 && flowerbed[i + 1] == 0)
        {
            max++;
            flowerbed[i] = 1;
        }
        pre = flowerbed[i];
    }
    if (flowerbed[size - 1] == 0 && pre == 0)           //判断最后一格是否适合种花
        max++;
    if (max >= n)
        return true;
    else
        return false;
}
//用最少的箭射气球
int findMinArrowShots(vector<vector<int>> &points)
{
    if (points.empty())
        return 0;
    int size = points.size();
    sort(points.begin(), points.end(), [](const vector<int> &a, const vector<int> &b)
         { return a[1] < b[1]; });
    int pos = points[0][1], arrow = 1;                  //射的点一定在某个气球的右边界
    for (const vector<int>& balloon: points) {
            if (balloon[0] > pos) {
                pos = balloon[1];
                ++arrow;
            }
        }
    return arrow;
}
