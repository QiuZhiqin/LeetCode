//x的平方根
int mySqrt(int x)
{
    if (x < 2)
        return x;
    int l = 1, r = x / 2, mid, sqrt;
    while (l <= r)
    {
        mid = (l + r) / 2;
        sqrt = x / mid;
        if (sqrt == mid)
            return mid;
        else if (sqrt > mid)
            l = mid + 1;
        else
            r = mid - 1;
    }
    return r;
}

//排序数组查找元素出现首位和最后一位（二分）
int firstmatch(const vector<int> &nums, int target)
{
    int l = 0, r = nums.size(), mid;
    while (l < r)
    {
        mid = (l + r) / 2;
        if (nums[mid] >= target)
            r = mid;
        else
            l = mid + 1;
    }
    return l;
}
vector<int> searchRange(vector<int> &nums, int target)
{
    int fir, las;
    fir = firstmatch(nums, target);
    las = firstmatch(nums, target + 1);
    if (fir==nums.size()||nums[fir] != target)
        return {-1, -1};
    else
        return {fir, las - 1};
}

//排序旋转数组搜索
bool search(vector<int> &nums, int target)
{
    int low = 0, high = nums.size() - 1, mid;
    while (low <= high)
    {
        mid = (low + high) / 2;
        if (nums[mid] == target)
            return true;
        else if (nums[low] == nums[mid])               //无法判断有序区间
            ++low;
        else if (nums[low] < nums[mid])                //左侧有序
        {
            if (nums[mid] > target&&target>=nums[low])
                high = mid - 1;
            else
                low = mid + 1;
        }
        else                                           //右侧有序
        {
            if (nums[mid] < target&&target<=nums[high])
                low = mid + 1;
            else
                high = mid - 1;
        }
    }
    return false;
}

//寻找旋转排序数组中的最小值
int findMin(vector<int> &nums)
{
    int low = 0, high = nums.size() - 1, mid;
    while (low < high)
    {
        mid = (low + high) / 2;
        if (nums[mid] > nums[high])
            low = mid + 1;
        else
            high = mid;
    }
    return nums[high];
}
};
